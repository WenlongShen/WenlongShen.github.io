---
layout:     post
title:      "Deep Learning Book 学习笔记（8）"
subtitle:   "Optimization for Training Deep Models"
date:       2018-05-09
author:     "Wenlong Shen"
header-img: "img/bg/2018_3.jpg"
tags: 机器学习 读书笔记 2018
---

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=default"></script>

*优化优化继续优化*

#### 学习和纯优化有什么不同

大多数机器学习是在间接地优化性能度量P，即通过降低代价函数$$J(\theta)$$来提高P，训练深度模型的优化算法通常也会包括一些针对机器学习目标函数的特定结构进行的特化。通常，我们更希望最小化取自数据生成分布$$P_{data}$$的期望，而不仅仅是有限训练集上的对应目标函数：

$$J^*(\theta)=E_{(x,y)~p_{data}}L(f(x;\theta),y)$$

机器学习算法的目标是上式所表示的期望泛化误差，这个数据量被称为风险（risk）。如果我们知道数据的真实分布，最小化过程就变成一个可优化过程，但实际情况是我们仅知道训练集中的样本分布，因而就变成了最小化经验风险，这个过程很容易过拟合，在实际中我们很少使用。有时，我们还会选择优化代理损失函数作为原目标的代理，来规避原函数可能存在的问题。

机器学习算法和一般优化算法不同的一点是，机器学习算法的目标函数通常可以分解为训练样本上的求和。在实践中，我们可以从数据集中随机采样少量的样本，然后计算这些样本上的平均值。使用整个训练集的优化算法被称为批量（batch）梯度下降，每次只使用单个样本的优化算法被称为随机（stochastic）或者在线（online）算法。随着数据集的规模迅速增长，超越了计算能力的增速，机器学习应用每个样本只使用一次的情况变得越来越常见，甚至是不完整地使用训练集。在使用一个非常大的训练集时，过拟合不再是问题，而欠拟合和计算效率变成了主要的顾虑。

#### 神经网络优化中的挑战

优化通常是一个极其困难的任务。常遇到的挑战比如有，矩阵病态问题即在随机梯度下降时会卡住，此时即使很小的更新步长也会增加代价函数；凸优化中可能遇到非常多的局部最小值、高原和鞍点等平坦区域；多层神经网络可能存在悬崖般的大斜率区域；计算图变得极深时，神经网络优化算法可能面临长期依赖问题，即由于变深的结构使模型丧失了学习到先前信息的能力，让优化变得极其困难；另外，实践中的优化算法还可能有非精确梯度的问题。一些理论结果表明，我们为神经网络设计的任何优化算法都有性能限制。

#### 基本算法

随机梯度下降及其变种可能是一般机器学习中应用最多的优化算法，伪代码如下：

	Require：学习率
	Require：初始参数
	    while 停止准则未满足 do
	        从训练集中采包含m个样本的小批量
	        计算梯度估计
	        更新参数
	    end while

我们还可以加入动量方法来加速学习，动量算法积累了之前梯度指数级衰减的移动平均，并且继续沿该方向移动。从形式上看，动量算法引入了变量$$v$$充当速度角色，代表参数在参数空间移动的方向和速率，速度被设为负梯度的指数衰减平均。

	Require：学习率、动量参数
	Require：初始参数、初始速度
	    while 停止准则未满足 do
	        从训练集中采包含m个样本的小批量
	        计算梯度估计
	        计算更新速度
	        更新参数
	    end while

#### 参数初始化策略

在实践中，训练深度模型是一个相当困难的问题，大多数算法都很大程度地受到初始化选择的影响。初始点能够决定算法是否收敛，有些初始点十分不稳定，使得该算法会遭遇数值困难，并完全失败，初始点也可以影响泛化。

初始参数需要在不同单元间“破坏对称性”，如果具有相同激活函数的两个隐藏单元连接到相同的输入，那么这些单元必须具有不同的初始参数。通常情况下，我们可以为每个单元的偏置设置启发式挑选的常数，仅随机初始化权重。计算资源允许的话，将每层权重的初始数值范围设为超参数通常是个好主意。另外地，我们还可以使用机器学习初始化模型参数，一个常用的策略是使用相同的输入数据集，用无监督模型训练出来的参数来初始化监督模型。

#### 自适应学习率算法

学习率通常是最难以设置的超参数之一，因为它对模型的性能有显著的影响。经典的自适应学习率算法如，AdaGrad算法，独立地适应所有模型参数的学习率，缩放每个参数反比于其所有梯度历史平方值总和的平方根，具有损失最大偏导的参数相应地有一个快速下降的学习率，而具有小偏导的参数在学习率上有相对较小的下降，其效果是在参数空间中更为平缓的倾斜方向会取得更大的进步。RMSProp算法，修改AdaGrad以在非凸设定下效果更好，改变梯度积累为指数加权的移动平均。AdaGrad旨在应用于凸问题时快速收敛，当应用于非凸函数训练神经网络时，学习轨迹可能穿过了很多不同的结构，最终到达一个局部是凸碗的区域，AdaGrad根据平方梯度的整个历史收缩学习率，可能使得学习率在达到这样的凸结构前就变得太小了，RMSProp使用指数衰减平均以丢弃遥远过去的历史，使其能够在找到凸碗状结构后快速收敛，它就像一个初始化于该碗状结构的AdaGrad算法实例。Adam是另一种学习率自适应的优化算法，可以被看作结合RMSProp和具有一些重要区别的动量的变种，其动量直接并入了梯度一阶矩（指数加权）的估计，Adam通常被认为对超参数的选择相当鲁棒。

#### 二阶近似方法

对于二阶梯度，常用的方法有牛顿法，其基于二阶泰勒级数展开而忽略高阶导数；共轭梯度法是一种通过迭代下降的共轭方向。

#### 优化策略和元算法

还有一些优化技术并非真正的算法，比如批标准化，以前的方法添加代价函数的惩罚，以鼓励单元标准化激活统计量，或是在每个梯度下降步骤之后重新标准化单元统计量。前者通常会导致不完全的标准化，而后者通常会显著地消耗时间，因为学习算法会反复改变均值和方差而标准化步骤会反复抵消这种变化。批标准化重参数化模型，以使一些单元总是被定义标准化，巧妙地回避了这两个问题。在某些情况下，将一个优化问题分解成几个部分，可以更快地解决原问题。如果我们相对于某个单一变量$$x_i$$最小化$$f(x)$$，然后相对于另一个变量$$x_j$$等等，反复循环所有的变量，我们会保证到达（局部）极小值，这种做法被称为坐标下降。有时，如果模型太复杂难以优化，或是如果任务非常困难，直接训练模型来解决特定任务的挑战可能太大，这时通过训练一个较简单的模型来求解问题，然后使模型更复杂，转移到最后的问题会更有效，这种在直接训练目标模型求解目标问题之前，训练简单模型求解简化问题的方法称为预训练。
